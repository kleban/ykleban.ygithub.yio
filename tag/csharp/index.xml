<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>csharp | kleban.page</title>
    <link>https://kleban.page/tag/csharp/</link>
      <atom:link href="https://kleban.page/tag/csharp/index.xml" rel="self" type="application/rss+xml" />
    <description>csharp</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2020 Yurii Kleban</copyright><lastBuildDate>Wed, 08 Jul 2020 00:00:00 +0100</lastBuildDate>
    <image>
      <url>https://kleban.page/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>csharp</title>
      <link>https://kleban.page/tag/csharp/</link>
    </image>
    
    <item>
      <title>Лекція 1. Вступ до основ програмування на платформі .NET</title>
      <link>https://kleban.page/courses/csharp-basics/lecture1/</link>
      <pubDate>Wed, 08 Jul 2020 00:00:00 +0100</pubDate>
      <guid>https://kleban.page/courses/csharp-basics/lecture1/</guid>
      <description>&lt;hr&gt;
&lt;h2&gt;План&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#11загальні-категорії-та-поняття-програмування&#34;&gt;1.1.	Загальні категорії та поняття програмування&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#12коротка-історія-програмування-та-виникнення-мови-c&#34;&gt;1.2.	Коротка історія програмування та виникнення мови C#&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#121парадигми-програмування&#34;&gt;1.2.1.	Парадигми програмування&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#122-процедурне-програмування&#34;&gt;1.2.2. Процедурне програмування&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#123-обєктне-модульне-програмування&#34;&gt;1.2.3. Об’єктне (модульне) програмування&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#124-обєктно-орієнтовне-програмування&#34;&gt;1.2.4. Об’єктно-орієнтовне програмування&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#13еволюція-мови-програмування-c&#34;&gt;1.3	Еволюція мови програмування C#&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#131створення-ооп-та-c&#34;&gt;1.3.1	Створення ООП та C++&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#132internet-та-поява-мови-java&#34;&gt;1.3.2	Internet та поява мови Java&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#133виникнення-c&#34;&gt;1.3.3.	Виникнення C#&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#14net-framework-поняття-та-структура&#34;&gt;1.4	.NET Framework: поняття та структура.&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#контрольні-запитання&#34;&gt;Контрольні запитання&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#список-використаних-джерел&#34;&gt;Список використаних джерел&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;hr&gt;
&lt;h2 id=&#34;11загальні-категорії-та-поняття-програмування&#34;&gt;1.1.	Загальні категорії та поняття програмування&lt;/h2&gt;
&lt;p&gt;Перед початком вивчення програмування варто розглянути та розібрати базові поняття та категорії. Дамо визначення понять: алгоритм, задача, програмування, мова програмування, програма, програмне забезпечення, розробка програмного забезпечення.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Програмування&lt;/strong&gt; – розробка програм за допомогою мов програмування.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Мова програмування&lt;/strong&gt; – це формальна система знаків, що призначена для написання програм, зрозуміла для виконавця (комп’ютера).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Програма&lt;/strong&gt; (&lt;code&gt;program&lt;/code&gt;, &lt;code&gt;routine&lt;/code&gt;) — впорядкована послідовність команд (інструкцій) комп&amp;rsquo;ютера для розв&amp;rsquo;язання задачі.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Програмне забезпечення&lt;/strong&gt; (&lt;code&gt;software&lt;/code&gt;) — сукупність програм обробки даних та необхідних для їх експлуатації документів. Програми призначені для машинної реалізації завдань (Задач). Терміни завдання і застосування (програма) мають дуже широке вживання в контексті інформатики і програмного забезпечення.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Завдання&lt;/strong&gt; або &lt;strong&gt;задача&lt;/strong&gt; (&lt;code&gt;problem&lt;/code&gt;, &lt;code&gt;task&lt;/code&gt;) — проблема, що підлягає вирішенню.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Застосування&lt;/strong&gt; або &lt;strong&gt;програма&lt;/strong&gt; (&lt;code&gt;application&lt;/code&gt;) — програмна реалізація на комп&amp;rsquo;ютері рішення задачі.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Розробка програмного забезпечення&lt;/strong&gt; (англ. &lt;code&gt;software engineering&lt;/code&gt;, &lt;code&gt;software development&lt;/code&gt;) — це рід діяльності (професія) і процес, спрямований на створення і підтримку працездатності, якості та надійності програмного забезпечення, використовуючи технології, методологію та практики з інформатики, управління проектами, математики, інженерії та інших сфер знань.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Алгоритм&lt;/strong&gt; (&lt;code&gt;Algorithmi&lt;/code&gt;, від імені перського математика IX ст. аль-Хорезмі) — система правил виконання обчислювального процесу, що обов&amp;rsquo;язково приводить до розв&amp;rsquo;язання певного класу задач після скінченного числа операцій. При написанні комп&amp;rsquo;ютерних програм алгоритм описує логічну послідовність операцій. Для візуального зображення алгоритмів часто використовують блок-схеми. Засоби швидкої розробки додатків (RAD) дозволяють створити програмний продукт, що складається з ряду застосувань, що дозволяють користувачам вводити дані в таблиці або редагувати вже існуючі дані, аналізувати введені дані і представляти їх у більш зручному для сприйняття вигляді - графіків, зведених таблиць або звітів (у тому числі у вигляді &amp;ldquo;паперових&amp;rdquo; документів).&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;12коротка-історія-програмування-та-виникнення-мови-c&#34;&gt;1.2.	Коротка історія програмування та виникнення мови C#&lt;/h2&gt;
&lt;h3 id=&#34;121парадигми-програмування&#34;&gt;1.2.1.	Парадигми програмування&lt;/h3&gt;
&lt;p&gt;Усе програмування прийнято поділяти на два основних види:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Декларативне.&lt;/li&gt;
&lt;li&gt;Імперативне.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Декларативне програмування&lt;/strong&gt; — термін з двома різними значеннями. Згідно першому визначенню, програма «декларативна», якщо вона описує щось, а не як його створити. Наприклад, веб-сторінки на HTML декларативні, оскільки вони описують що повинна містити сторінка, а не як відображати сторінку на екрані. Цей підхід відрізняється від мов імперативного програмування, що вимагають від програміста вказувати алгоритм для виконання.&lt;/p&gt;
&lt;p&gt;Згідно другому визначенню, програма «декларативна», якщо вона написана на виключно функціональній, логічній або константній мові програмування.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Імперативне програмування&lt;/strong&gt; — парадигма програмування, згідно з якою описується процес отримання результатів як послідовність інструкцій зміни стану програми. Подібно до того, як з допомогою наказового способу в мовознавстві перелічується послідовність дій, що необхідно виконати, імперативні програми є послідовністю операцій комп&amp;rsquo;ютеру для виконання.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Парадигма програмування&lt;/strong&gt; — це спосіб мислення розробника програми. Мова програмування може підтримувати або не підтримувати ту чи іншу парадигму. В першому випадку застосування парадигми стає зручним, тобто простим, безпечним і ефективним. Ми розглянемо три основних наказових парадигми — процедурне, об’єктне (модульне) і об’єктно-орієнтовне (ієрархічне) програмування.&lt;/p&gt;
&lt;h3 id=&#34;122-процедурне-програмування&#34;&gt;1.2.2. Процедурне програмування&lt;/h3&gt;
&lt;p&gt;Процедурне програмування подає програму у вигляді набору алгоритмів, для оформлення яких можуть застосовуватися іменовані програмні блоки — процедури і функції. В останньому випадку передбачається наявність механізмів передачі параметрів і поверненні результату.&lt;/p&gt;
&lt;p&gt;Спочатку процедурне програмування користувалося довільними засобами керування, в тому числі, переходом за міткою — одним з найбільш вживаних операторів керування в Фортрані.&lt;/p&gt;
&lt;p&gt;До мов процедурного програмування відносяться Fortran, Cobol, Pascal, Basic, та інші.&lt;/p&gt;
&lt;p&gt;В 1968 році голландський вчений Е. Дейкстра вперше звернув увагу на проблеми, що виникають у програмах з неконтрольованими переходами, в 1970 році проголосив новий напрямок, який він назвав структур(ова)ним програмуванням.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Структурне програмування&lt;/strong&gt; — це варіант процедурного, що вживає три типи структур керування: послідовне виконання дій, розгалуження і цикл. Не дивно, що Фортран не підтримував цю парадигму — в наборі його засобів не було циклів за умовами. Починаючи з Алголу, а особливо в Паскалі, цикли стають основним засобом організації обчислень в програмі.&lt;/p&gt;
&lt;p&gt;Автор Паскалю, професор Н. Вірт, відібрав до створюваної ним мови програмування лише прості в поясненні і легкі в реалізації конструкції. Завдяки сильній типізації програми в Паскалі відзначаються високою надійністю, вони мобільні завдяки закладеній в них концепції Паскаль-машини, їх легко читати і розуміти завдяки дисципліні програмування, продиктованої вжитою парадигмою.&lt;/p&gt;
&lt;p&gt;Але разом з цим застосування Паскалю гальмувалося саме складністю виходу за межі віртуальної машини, потребою ефективного використання наявної апаратури. Головним критерієм, вжитим Б.Керніганом і Д.Річі до створеної ними мови С, стала саме гнучкість використання особливостей конкретної апаратури і ефективність виконання програм.&lt;/p&gt;
&lt;h3 id=&#34;123-обєктне-модульне-програмування&#34;&gt;1.2.3. Об’єктне (модульне) програмування&lt;/h3&gt;
&lt;p&gt;Процедурна парадигма віддала належне алгоритмічній компоненті програмування. Але з ростом обсягу програм і складності даних з&amp;rsquo;явилася нова проблема структурної організації даних, найбільш ємко висловлена Віртовською формулою &lt;strong&gt;&lt;code&gt;алгоритми + структури даних = програми&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Поняття модуля як абстракції даних було вперше запропоноване Парнасом у 
1972 році, правда на той час уже існувала мова програмування Симула 67, в якій використовувалася парадигма об&amp;rsquo;єктів. У найбільш повному виді поняття абстракції даних було реалізоване в мові програмування Модула-2.&lt;/p&gt;
&lt;p&gt;Головна ідея полягає в забезпеченні доступу до даних, не залежному від їх конкретного представлення. Самі дані і програми їх обробки вбудовуються (інкапсулюються) в окремій одиниці програми.&lt;/p&gt;
&lt;h3 id=&#34;124-обєктно-орієнтовне-програмування&#34;&gt;1.2.4. Об’єктно-орієнтовне програмування&lt;/h3&gt;
&lt;p&gt;Об&amp;rsquo;єктно-орієнтована парадигма наділила класи ієрархією.&lt;/p&gt;
&lt;p&gt;Об&amp;rsquo;єктно-орієнтоване програмування за метафорою Б.Страуструпа, автора &lt;code&gt;С++&lt;/code&gt; — однієї з найпопулярніших мов об&amp;rsquo;єктно-орієнтованого програмування, — це високоінтелектуальний синонім доброго програмування. Дійсно, нові парадигми програмування з&amp;rsquo;являються не так часто, не частіше однієї в десятиліття. Той факт, що об&amp;rsquo;єктно-орієнтована парадигма успішно використовується протягом 20 років, сам по собі служить вагомим підтвердженням її життєздатності.&lt;/p&gt;
&lt;p&gt;Алгоритми, реалізовані в процедурному програмуванні, надто конкретні. Будь-яка модифікація — це вже новий алгоритм і таким чином кількість процедур і функцій, що знаходяться у використанні, надмірно зростає. Модульне програмування групує алгоритми в модулі, одночасно інкапсулюючи структури даних. Тепер залишається зробити наступний крок — побудувати ієрархію модулів або класів.&lt;/p&gt;
&lt;p&gt;Таких ієрархій може бути дві. Перша з них — бути частиною чогось. Наприклад, грань є частиною многогранника, ребро — частиною грані, вершина — частиною ребра. Інша ієрархія — бути узагальненням або конкретизацією.&lt;/p&gt;
&lt;p&gt;Наприклад, овал і многокутник служать конкретизацією плоскої фігури, коло — конкретизацією овалу, чотирикутник — конкретизацією многокутника, подальшими конкретизаціями чотирикутника можуть служити паралелограм, прямокутник, ромб, квадрат. Той факт, що квадрат, ромб, прямокутник є повноцінними паралелограмами дозволяє їм користуватися усіма програмними засобами, створеними для паралелограма, паралелограм в свою чергу є повноцінним чотирикутником і так далі. Цей принцип, відомий під назвою &lt;code&gt;reusable&lt;/code&gt; — знову вживаний — став одним з найважливіших досягнень об&amp;rsquo;єктно-орієнтованої парадигми. Знову вживаючи вже існуюче програмне забезпечення в більш конкретизованих умовах, ми дописуємо лише ту його частину, яка стосується особливостей наявної конкретизації. Цей принцип дістав назву &lt;code&gt;programming by difference&lt;/code&gt; або дописування програм.&lt;/p&gt;
&lt;p&gt;І, нарешті, об&amp;rsquo;єктно-орієнтована парадигма доводить до логічної завершеності принцип моделювання реального світу, а точніше тієї його частини, абстракцією якої служить програма. При цьому підході програма складається з об&amp;rsquo;єктів, що відповідають реальним поняттям або предметам. Виконання програми зводиться до взаємодії об&amp;rsquo;єктів, яке служить абстракцією реальної взаємодії їх прототипів. Все це разом забезпечило об&amp;rsquo;єктно-орієнтованому підходу беззаперечне лідерство в галузі розробки програм.&lt;/p&gt;
&lt;p&gt;Сьогодні в сімействі мов об&amp;rsquo;єктно-орієнтованого програмування три найбільш відомих представника: &lt;code&gt;С++&lt;/code&gt;, &lt;code&gt;Java&lt;/code&gt; і &lt;code&gt;C#&lt;/code&gt; ( читається Сі шарп ). &lt;code&gt;С++&lt;/code&gt; і сьогодні залишається визнаним лідерів в розробці великих і складних програмних систем. &lt;code&gt;Java&lt;/code&gt; і &lt;code&gt;C#&lt;/code&gt; виросли з &lt;code&gt;С++&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;13еволюція-мови-програмування-c&#34;&gt;1.3	Еволюція мови програмування C#&lt;/h2&gt;
&lt;h3 id=&#34;131створення-ооп-та-c&#34;&gt;1.3.1	Створення ООП та C++&lt;/h3&gt;
&lt;p&gt;До кінця 1970-х розмір проектів став наближатися до критичного, при перевищенні якого методика структурного програмування і мова &lt;code&gt;С&lt;/code&gt; &amp;ldquo;опускали руки&amp;rdquo;. Тому стали з&amp;rsquo;являтися нові підходи до програмування, що дозволяють вирішити цю проблему. Один з них отримав назву об&amp;rsquo;єктно-орієнтованого програмування (ООП). Використовуючи ООП, програміст міг справлятися з програмами набагато більшого розміру, ніж раніше. Але проблема полягала у тому, що &lt;code&gt;С&lt;/code&gt;, найпопулярніша на той час мова, не підтримувала ООП. Бажання працювати з об&amp;rsquo;єктно-орієнтованою версією мови С врешті-решт і привело до створення &lt;code&gt;C++&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Мова &lt;code&gt;C++&lt;/code&gt; була розроблена Бьорном Страуструпом (&lt;code&gt;Bjarne Stroustrup&lt;/code&gt;) в компанії Bell Laboratories (Нью-Джерсі), роком створення вважається 1979-й. Спочатку творець нової мови назвав її &amp;ldquo;С з класами&amp;rdquo;, але в 1983 році це ім&amp;rsquo;я було змінене на &lt;code&gt;C++&lt;/code&gt;. &lt;code&gt;C++&lt;/code&gt; повністю включає елементи мови &lt;code&gt;С&lt;/code&gt;. Таким чином, С можна вважати фундаментом, на якому побудований &lt;code&gt;C++&lt;/code&gt;. Більшість доповнень, які Страуструп вніс до &lt;code&gt;С&lt;/code&gt;, були призначені для підтримки об&amp;rsquo;єктно-орієнтованого програмування. По суті, C++ - це об&amp;rsquo;єктно-орієнтована версія мови С. Створюючи &lt;code&gt;С++&lt;/code&gt; на основі С Страуструп забезпечив плавний перехід багатьох програмістів на ООП.&lt;/p&gt;
&lt;p&gt;Замість необхідності вивчати абсолютно нову мову, &lt;code&gt;С&lt;/code&gt;-програмістові досить було освоїти лише нові засоби, що дозволяють використовувати переваги об&amp;rsquo;єктно-орієнтованої методики.&lt;/p&gt;
&lt;p&gt;Впродовж 1980-х років &lt;code&gt;C++&lt;/code&gt; інтенсивно розвивалася і на початок 1990-х вже була готовп для широкого використання. Зростання її популярності носило вибухоподібний характер, і до кінця цього десятиліття вона стала найбільш використовуваною мовою програмування. В наші дні мова &lt;code&gt;C++&lt;/code&gt; як і раніше має безперечну перевагу при розробці високопродуктивних програм системного рівня.&lt;/p&gt;
&lt;h3 id=&#34;132internet-та-поява-мови-java&#34;&gt;1.3.2	Internet та поява мови Java&lt;/h3&gt;
&lt;p&gt;Наступним рівнем на сходах прогресу мов програмування стала мова Java, яка спочатку називалася Oak (у перекладі з англ. &amp;ldquo;дуб&amp;rdquo;). Робота над її створенням почалася в 1991 році в компанії Sun Microsystems. Основною рушійною силою розробки Java був Джеймс Гослінг (James Gosling).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; - це структурна об&amp;rsquo;єктно-орієнтована мова програмування, синтаксис і принципи якої &amp;ldquo;родом&amp;rdquo; з &lt;code&gt;C++&lt;/code&gt;. Своїми новаторськими аспектами &lt;code&gt;Java&lt;/code&gt; зобов&amp;rsquo;язана не стільки прогресу в мистецтві програмування (хоча і це мало місце), скільки змінам в комп&amp;rsquo;ютерному середовищі. Ще до настання ери Internet більшість програм писалися, компілювалися і призначалися для виконання з використанням певного процесора і під управлінням конкретної операційної системи. Не дивлячись на те що програмісти завжди прагнули робити свої програми так, щоб їх можна було застосовувати неодноразово, можливість легко переносити програму з одного середовища в іншу не була ще досягнута, до того ж проблема переносимості постійно вікладалися, вирішувалися ж більш насущні проблеми. Проте з появою всесвітньої мережі Internet, в якій виявилися зв&amp;rsquo;язаними різні типи процесорів і операційних систем, стара проблема портативності заявила про себе вже в повний голос. Для її вирішення знадобилася нова мова програмування, і нею стала &lt;code&gt;Java&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Цікаво відзначити, що, хоча єдиним найбільш важливим аспектом &lt;code&gt;Java&lt;/code&gt; (і причиною швидкого визнання) є можливість створювати на ній кросплатформений (сумісний з декількома операційними середовищами) переносимий програмний код, вихідним імпульсом для виникнення &lt;code&gt;Java&lt;/code&gt; стала не мережа Internet, а наполеглива потреба у незалежній від платформи мові, яку можна було б використовувати в процесі створення програмного забезпечення для вбудованих контролерів. У 1993 році стало очевидним, що проблеми міжплатформеної переносимості, що чітко виявилися при створенні коду в вбудованих контролерів, також виявилися актуальними при спробі написати код для Internet. Адже Internet - це величезне комп&amp;rsquo;ютерне середовище, в якому &amp;ldquo;мешкає&amp;rdquo; безліч комп&amp;rsquo;ютерів різних типів. І виявилось, що одні і ті ж методи вирішення проблеми переносимості в малих масштабах можна успішно застосувати і до набагато більших, тобто в Internet У Java переносимість досягається за допомогою перетворення вихідного коду програми в проміжний код, що іменується байт-кодом), тобто машинно-незалежний код, що генерується Java-компілятором. Байт-код виконується віртуальною машиною &lt;code&gt;Java&lt;/code&gt; (&lt;code&gt;Java Virtual Machine - JVM&lt;/code&gt;) - спеціальною операційною системою. Отже, Java-программа могла б працювати в будь-якому середовищі, де доступна JVM. А оскільки JVM відносно проста для реалізації, вона швидко стала доступною для великої кількості середовищ.&lt;/p&gt;
&lt;p&gt;Використання Java-програмами байт-коду радикально відрізняло їх від &lt;code&gt;С&lt;/code&gt;- і &lt;code&gt;С++&lt;/code&gt;-програм. Якщо &lt;code&gt;С/С++&lt;/code&gt;-программу потрібно виконати в іншій системі, її необхідно перекомпілювати в машинний код, відповідний цьому середовищу. Отже, аби створити С/С++-програму, призначену для виконання в різних середовищах, необхідно мати декілька різних виконуваних (машинних) версій цієї програми. Це було непрактично і дорого. І навпаки, використання для виконання &lt;code&gt;Java&lt;/code&gt;-программ проміжної мови було елегантним і рентабельним рішенням. Саме це рішення було адаптоване для мови &lt;code&gt;С#&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;133виникнення-c&#34;&gt;1.3.3.	Виникнення C#&lt;/h3&gt;
&lt;p&gt;Розробники &lt;code&gt;Java&lt;/code&gt; успішно вирішили багато проблем, пов&amp;rsquo;язаних з переносимістю в середовищі Internet, але далеко не всі. Одна з них - міжмовна можливість взаємодії (&lt;code&gt;cross-language interoperability&lt;/code&gt;) програмних і апаратних виробів різних постачальників, або багатомовне програмування (mixed-language programming). В разі вирішення цієї проблеми програми, написані на різних мовах, могли б успішно працювати одна з іншою. Така взаємодія необхідна для створення великих систем з розподіленим програмним забезпеченням (ПЗ), а також для програмування компонентів ПЗ, оскільки найціннішим є компонент, який можна використовувати у широкому діапазоні комп&amp;rsquo;ютерних мов і операційних середовищ.&lt;/p&gt;
&lt;p&gt;Крім того, в &lt;code&gt;Java&lt;/code&gt; не досягнута повна інтеграція з платформою &lt;code&gt;Windows&lt;/code&gt;. Хоча &lt;code&gt;Java&lt;/code&gt;-програми можуть виконуватися в середовищі Windows (за умови встанолення віртуальної машини &lt;code&gt;Java&lt;/code&gt;), &lt;code&gt;Java&lt;/code&gt; і &lt;code&gt;Windows&lt;/code&gt; не є міцно зв&amp;rsquo;язаними середовищами. А оскільки Windows - це найбільш широко використовувана операційна система в світі, відсутність прямої підтримки &lt;code&gt;Windows&lt;/code&gt; - серйозний недолік &lt;code&gt;Java&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Аби задовольнити ці потреби, &lt;code&gt;Microsoft&lt;/code&gt; розробила мову &lt;code&gt;С#&lt;/code&gt;, &lt;code&gt;С#&lt;/code&gt; була створена в кінці 1990-х років і стала частиною спільної &lt;code&gt;.NET&lt;/code&gt;-стратегії &lt;code&gt;Microsoft&lt;/code&gt;. Вперше вона побачила світло як альфа-версія в середині 2000 року. Головним архітектором С# був Андерс Хейлсберг (&lt;code&gt;Anders Hejlsberg&lt;/code&gt;) - один з провідних фахівців в області мов програмування, що отримав визнання у всьому світі. Досить сказати, що в 1980-х він був автором успішного продукту &lt;code&gt;Turbo Pascal&lt;/code&gt;, витончена реалізація якого встановила стандарт для всіх майбутніх компіляторів.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
  C--&amp;gt;C++;
  C++--&amp;gt;Java;
  C++--&amp;gt;C#;
&lt;/code&gt;&lt;/pre&gt;
&lt;center&gt;Рис. 1.1. Розвиток мов програмування `C/C++/Java/C#`&lt;/center&gt;
&lt;p&gt;&lt;code&gt;С#&lt;/code&gt; безпосередньо пов&amp;rsquo;язаний із &lt;code&gt;С&lt;/code&gt;, &lt;code&gt;C++&lt;/code&gt; і &lt;code&gt;Java&lt;/code&gt;. І це не випадково. Ці три мови - найпопулярніші і найулюбленіші мови програмування в світі. Більш того, майже всі професійні програмісти сьогодні знають &lt;code&gt;С&lt;/code&gt; і &lt;code&gt;C++&lt;/code&gt;, і більшість знає &lt;code&gt;Java&lt;/code&gt;. Оскільки &lt;code&gt;С#&lt;/code&gt; побудований на міцному, зрозумілому фундаменті, то перехід від цих &amp;ldquo;фундаментальних&amp;rdquo; мов до &amp;ldquo;надбудови&amp;rdquo; відбувається без особливих зусиль з боку програмістів. Оскільки Андерс Хейлсберг не збирався винаходити нову мову, він зосередився на введенні удосконалень.&lt;/p&gt;
&lt;p&gt;Прамовою &lt;code&gt;С#&lt;/code&gt; є мова &lt;code&gt;С&lt;/code&gt;. Від С мова С# успадкувала синтаксис, багато ключових слів і оператори. Крім того, &lt;code&gt;С#&lt;/code&gt; побудований на покращеній об&amp;rsquo;єктній моделі, визначеній в &lt;code&gt;C++&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;С#&lt;/code&gt; і &lt;code&gt;Java&lt;/code&gt; зв&amp;rsquo;язані між собою дещо складніше. Як згадувалося вищим, Java також є нащадком С і C++. У неї теж загальний з нею синтаксис і схожа об&amp;rsquo;єктна модель. Подібно &lt;code&gt;Java&lt;/code&gt; &lt;code&gt;C#&lt;/code&gt; призначений для створення переносимого коду. Проте &lt;code&gt;С#&lt;/code&gt; - не нащадок &lt;code&gt;Java&lt;/code&gt;. Швидше &lt;code&gt;С#&lt;/code&gt; і &lt;code&gt;Java&lt;/code&gt; можна вважати двоюрідними братами, що мають загальних предків, але що отримали від батьків різні набори &amp;ldquo;генів&amp;rdquo;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;14net-framework-поняття-та-структура&#34;&gt;1.4	.NET Framework: поняття та структура.&lt;/h2&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;Платформа&lt;/strong&gt; — у контексті інформаційних технологій - середовище, що забезпечує виконання програмного коду. Платформа визначається характеристиками процесорів, особливостями операційних систем.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Framework&lt;/code&gt;&lt;/strong&gt; — це інфраструктура середовища виконання програм, щось, що визначає особливості розробки і виконання програмного коду на даній платформі. Передбачає засоби організації взаємодії з операційною системою і прикладними програмами, методи доступу до баз даних, засоби підтримки розподілених (мережевих) додатків, мови програмування, безліч базових класів, уніфіковані інтерфейси користувача, парадигми програмування.
&lt;code&gt;Microsoft .NET&lt;/code&gt; — платформа.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;.NET Framework&lt;/code&gt;&lt;/strong&gt; — інфраструктура платформи Microsoft .NET. Включає наступні основні компоненти: &lt;code&gt;Common Language Runtime&lt;/code&gt; (&lt;code&gt;CLR&lt;/code&gt;) і &lt;code&gt;.NET Framework Class Library&lt;/code&gt; (&lt;code&gt;.NET FCL&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;CLS&lt;/code&gt; (&lt;code&gt;Common Language Specification&lt;/code&gt;)&lt;/strong&gt; — загальна специфікація мов програмування. Це набір конструкцій і обмежень, які є інструкцією для розробників бібліотек і компіляторів в середовищі &lt;code&gt;.NET Framework&lt;/code&gt;. Бібліотеки, побудовані відповідно до &lt;code&gt;CLS&lt;/code&gt;, можуть бути використані у будь-якій мові програмування, що підтримує &lt;code&gt;CLS&lt;/code&gt;.
Мови, відповідні &lt;code&gt;CLS&lt;/code&gt; (до їх числа відносяться мови &lt;code&gt;Visual C#&lt;/code&gt;, &lt;code&gt;Visual Basic&lt;/code&gt;, &lt;code&gt;Visual C++&lt;/code&gt;), можуть інтегруватися один з одним. &lt;code&gt;CLS&lt;/code&gt; - це основа міжмовної взаємодії в рамках платформи &lt;code&gt;Microsoft .NET&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;CLR&lt;/code&gt; (&lt;code&gt;Common Language Runtime&lt;/code&gt;)&lt;/strong&gt; — Середовище Часу Виконання або Віртуальна Машина. Забезпечує виконання збірки. Основний компонент &lt;code&gt;.NET Framework&lt;/code&gt;. Під Віртуальною Машиною розуміють абстракцію інкапсульованої (відособленої) керованої операційної системи високого рівня, яка забезпечує виконання (керованого) програмного коду.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Керований код&lt;/strong&gt; — програмний код, який під час виконання здатний використовувати служби, що надаються &lt;code&gt;CLR&lt;/code&gt;. Відповідно, некерований код подібною здатністю не володіє.&lt;/p&gt;
&lt;p&gt;Тобто, &lt;code&gt;CLR&lt;/code&gt; - це набір служб, необхідних для виконання керованого коду. Сама &lt;code&gt;CLR&lt;/code&gt; складається з двох головних компонентів: ядра (&lt;code&gt;mscoree.dll&lt;/code&gt;) і бібліотеки базових класів (&lt;code&gt;mscorlib.dll&lt;/code&gt;). Наявність цих файлів на диску - ознака того, що на комп&amp;rsquo;ютері, принаймні, була зроблена спроба встановлення платформи &lt;code&gt;.NET&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;FCL&lt;/code&gt; (&lt;code&gt;.NET Framework Class Library&lt;/code&gt;)&lt;/strong&gt; — відповідна &lt;code&gt;CLS&lt;/code&gt;-спеціфікаціії об&amp;rsquo;єктно-орієнтована бібліотека класів, інтерфейсів і системи типів (типів-значень), які включаються до складу платформи Microsoft &lt;code&gt;.NET&lt;/code&gt;. Ця бібліотека забезпечує доступ до функціональних можливостей системи і призначена служити основою при розробці &lt;code&gt;.NET&lt;/code&gt;-додатків, компонент, елементів управління.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.NET&lt;/code&gt; бібліотека класів є другим компонентом &lt;code&gt;CLR&lt;/code&gt;. &lt;code&gt;.NET FCL&lt;/code&gt; можуть використовувати усі&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.NET&lt;/code&gt;-додатки, незалежно від призначення архітектури використовуваного при розробці мови програмування, і зокрема:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;вбудовані (елементарні) типи, представлені у вигляді класів (на платформі .NET все побудовано на структурах або класах);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;класи для розробки графічного користувацького інтерфейсу (&lt;code&gt;Windows Forms&lt;/code&gt;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;класи для розробки &lt;code&gt;web&lt;/code&gt;-додатків і &lt;code&gt;web&lt;/code&gt;-служб на основі технології &lt;code&gt;ASP.NET&lt;/code&gt; (&lt;code&gt;Web Forms&lt;/code&gt;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;класи для розробки &lt;code&gt;XML&lt;/code&gt; і Internet-протоколів (&lt;code&gt;FTP&lt;/code&gt;, &lt;code&gt;HTTP&lt;/code&gt;, &lt;code&gt;SMTP&lt;/code&gt;, &lt;code&gt;SOAP&lt;/code&gt;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;класи для розробки додатків, що працюють з базами даних (&lt;code&gt;ADO .NET&lt;/code&gt;) і багато що інших.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;.NET&lt;/code&gt;-застосування&lt;/strong&gt; — програма, розроблена для виконання на платформі &lt;code&gt;Microsoft .NET&lt;/code&gt;. Реалізується на мовах програмування, відповідних &lt;code&gt;CLS&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;MSIL&lt;/code&gt; (&lt;code&gt;Microsoft Intermediate Language&lt;/code&gt;)&lt;/strong&gt; — проміжна мова платформи &lt;code&gt;Microsoft .NET&lt;/code&gt;. Вихідні тексти програм для &lt;code&gt;.NET&lt;/code&gt;-додатків пишуться на мовах програмування, відповідних специфікації &lt;code&gt;CLS&lt;/code&gt;. Для таких мов може бути побудований перетворювач в &lt;code&gt;MSIL&lt;/code&gt;. Таким чином, програми на цих мовах можуть транслюватися в проміжний код на &lt;code&gt;MSIL&lt;/code&gt;. Завдяки відповідності &lt;code&gt;CLS&lt;/code&gt;, в результаті трансляції програмного коду, написаного на різних мовах, виходить сумісний &lt;code&gt;IL&lt;/code&gt;-код.&lt;/p&gt;
&lt;p&gt;Схема виконання .NET додатків у середовищі CLR:&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-12-процес-запуску-net-програми&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-1-dotnet-code-run.svg&#34; data-caption=&#34;1.2. Процес запуску .NET-програми&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-1-dotnet-code-run.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    1.2. Процес запуску .NET-програми
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Усі блок-схеми створено у &lt;em&gt;draw.io&lt;/em&gt;.&lt;br&gt; Файли можна знайти &lt;a href=&#34;https://github.com/kleban/csharp-basics-public/blob/master/diagrams&#34;&gt;у github репозиторії курсу&lt;/a&gt;.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;У середовищі &lt;code&gt;CLR&lt;/code&gt; допускається спільна робота і взаємодія компонентів програмного забезпечення, реалізованих на різних мовах програмування. CLR бере на себе вирішення багатьох проблем, які традиційно знаходилися в зоні особливої уваги розробників програмного забезпечення.&lt;/p&gt;
&lt;p&gt;До функцій, виконуваних &lt;code&gt;CLR&lt;/code&gt;, відносяться:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Перевірка і динамічна (&lt;code&gt;JIT&lt;/code&gt;) компіляція &lt;code&gt;MSIL&lt;/code&gt;-коду у команди процесора.&lt;/li&gt;
&lt;li&gt;Управління пам&amp;rsquo;яттю, процесами і потоками.&lt;/li&gt;
&lt;li&gt;Організація взаємодії процесів.&lt;/li&gt;
&lt;li&gt;Вирішення проблем безпеки (в рамках безпеки, що існує в системі політики).&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-question-circle fa-2x text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;контрольні-запитання&#34;&gt;Контрольні запитання&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Дати визначення поняття алгоритм?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Дати визначення поняття програма?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Дати визначення поняття задача?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Дати визначення поняття програмне забезпечення?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Дати визначення поняття розробка програмного забезпечення?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Яка відмінність між програмою та програмним забезпеченням?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-book fa-2x text-primary  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;список-використаних-джерел&#34;&gt;Список використаних джерел&lt;/h2&gt;
&lt;!--
---


  &lt;i class=&#34;fas fa-list-alt fa-2x text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
## Задачі
--&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Дорогі друзі, якщо Ви помітили, що для написання матеріалів використані джерела, які я не вказав - прошу надіслати мені інформацію на пошту.
Дякую.
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Лекція 2. Основи алгоритмізації</title>
      <link>https://kleban.page/courses/csharp-basics/lecture2/</link>
      <pubDate>Wed, 08 Jul 2020 00:00:00 +0100</pubDate>
      <guid>https://kleban.page/courses/csharp-basics/lecture2/</guid>
      <description>&lt;hr&gt;
&lt;h2&gt;План&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#21поняття-та-характеристики-алгоритмів&#34;&gt;2.1.	Поняття та характеристики алгоритмів&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#22-побудова-алгоритмів-з-використанням-блок-схем&#34;&gt;2.2. Побудова алгоритмів з використанням блок-схем&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#23ствоерення-блок-схем-з-використанням-diagramm-designer&#34;&gt;2.3.	Ствоерення блок-схем з використанням Diagramm Designer&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#24ствоерення-блок-схем-з-використанням-drawio&#34;&gt;2.4.	Ствоерення блок-схем з використанням draw.io&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#контрольні-запитання&#34;&gt;Контрольні запитання&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#список-використаних-джерел&#34;&gt;Список використаних джерел&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#додаткові-матеріали-для-завнатаження&#34;&gt;Додаткові матеріали для завнатаження&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;hr&gt;
&lt;h2 id=&#34;21поняття-та-характеристики-алгоритмів&#34;&gt;2.1.	Поняття та характеристики алгоритмів&lt;/h2&gt;
&lt;p&gt;Слово алгоритм походить від імені перського вченого, астронома та математика Аль-Хорезмі. Близько 825 до н. е. він написав трактат, в якому описав придуману в Індії позиційну десяткову систему числення. В першій половині XII століття книжка потрапила до Європи в перекладі латинською мовою під назвою Algoritmi de numero Indorum. Вважається, що перше слово в перекладі відповідає невдалій латинізації імені Аль-Хорезмі, а назва перекладу звучить як «Алгорітмі про індійську лічбу».&lt;/p&gt;
&lt;p&gt;Перший алгоритм, призначений для виконання на автоматичному обчислювальному пристрої (комп&amp;rsquo;ютері), описала Ада Лавлейс в 1843 році. Алгоритм мав обчислювати числа Бернуллі й працювати на аналітичній машині Беббіджа. Цей алгоритм вважається першою комп&amp;rsquo;ютерною програмою, а його розробниця, Ада Лавлейс — першим програмістом.&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-21-баронеса-ада-лавлейс-яку-вважають-першим-програмістом-джерело-wikipedia&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/334px-Ada_Lovelace_portrait.jpg&#34; data-caption=&#34;Рис. 2.1. Баронеса Ада Лавлейс, яку вважають першим програмістом. Джерело: Wikipedia&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/334px-Ada_Lovelace_portrait.jpg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.1. Баронеса Ада Лавлейс, яку вважають першим програмістом. Джерело: Wikipedia
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;p&gt;Розглянемо визначення поняття алгоритм.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Алгоритм&lt;/strong&gt; являє собою послідовність розпоряджень виконавцю. Виконавець повинен неухильно виконувати ці розпорядження. Число таких розпоряджень не є обов&amp;rsquo;язковим: воно може складати кілька тисяч, мільйонів і навіть трильйонів, але воно не може бути нескінченним. І коли виконавець виконає всі розпорядження, задача, для якої був створений алгоритм, буде вирішена.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Алгоритм&lt;/strong&gt; — система правил виконання обчислювального процесу, що обов&amp;rsquo;язково приводить до розв&amp;rsquo;язання певного класу задач після скінченного числа операцій. При написанні комп&amp;rsquo;ютерних програм алгоритм описує логічну послідовність операцій. Для візуального зображення алгоритмів часто використовують блок-схеми.&lt;/p&gt;
&lt;p&gt;Кожен алгоритм є списком точно визначених інструкцій для розв&amp;rsquo;язання задачі. Починаючи з початкового стану, інструкції алгоритму описують процес обчислення, які відбуваються через послідовність станів, які, зрештою, завершуються кінцевим станом. Перехід з одного стану до наступного не обов&amp;rsquo;язково детермінований — деякі алгоритми містять елементи випадковості.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Алгоритм&lt;/strong&gt; — це опис процесу вирішення того чи іншого завдання. Алгоритмом називається кінцевий набір правил, розташованих у певному логічному порядку, що дозволяє виконавцю вирішувати будь-яку конкретну задачу з деякого класу однотипних задач.&lt;/p&gt;
&lt;p&gt;Алгоритми мають ряд важливих властивостей:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;strong&gt;Скінченність&lt;/strong&gt;. Алгоритм має завжди завершуватись після виконання скінченної кількості кроків. Процедуру, яка має решту характеристик алгоритму, без, можливо, скінченності, називають методом обчислень.&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Дискретність. Процес, що визначається алгоритмом, можна розчленувати (розділити) на окремі елементарні етапи (кроки), кожен з яких називається кроком алгоритмічного процесу чи алгоритму.&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;strong&gt;Визначеність&lt;/strong&gt;. Кожен крок алгоритму має бути точно визначений. Дії, які необхідно здійснити, повинні бути чітко та недвозначно визначені для кожного можливого випадку.&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;strong&gt;Вхідні дані&lt;/strong&gt;. Алгоритм має деяку кількість (можливо, нульову) вхідних даних, тобто, величин, заданих до початку його роботи або значення яких визначають під час роботи алгоритму.&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;strong&gt;Вихідні дані&lt;/strong&gt;. Алгоритм має одне або декілька вихідних даних, тобто, величин, що мають досить визначений зв&amp;rsquo;язок із вхідними даними.&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;strong&gt;Ефективність&lt;/strong&gt;. Алгоритм вважають ефективним, якщо всі його оператори досить прості для того, аби їх можна було точно виконати за скінченний проміжок часу з допомогою олівця та аркушу паперу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Виділяють наступні основні способи запису алгоритмів:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;вербальний&lt;/strong&gt;&lt;/em&gt; - алгоритм описується на природній мові;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;символьний&lt;/strong&gt;&lt;/em&gt; - алгоритм описується за допомогою набору символів;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;графічний&lt;/strong&gt;&lt;/em&gt; - алгоритм описується за допомогою набору графічних зображень.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Розглянемо приклад розв&amp;rsquo;язання задачі.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-question-circle text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Задача 1.&lt;/strong&gt; Скласти алгоритм ров’язання квадратного рівняння на комп’ютері та записати його вербальним способом (описати словами). Нагадаємо, квадратне рівняння має вигляд: $ {ax^2 + bx + c = 0} $.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-check-circle text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Етапи розв&amp;rsquo;язання задачі:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Вводимо значення $ a $, $ b $, $ c $.&lt;/li&gt;
&lt;li&gt;Обчислюємо дискримінант за фрмулою $ d = b^2 - 4ac $.&lt;/li&gt;
&lt;li&gt;Якщо $ d &amp;gt; 0 $ обчислити корені $ x_1 $, $ x_2 $ за формулою $ x=\frac {b ± \sqrt{d}}{2a} $ та вивести їх значення на екран.
Інакше, якщо $ d = 0 $ – обчислити $ x_1=-\frac{b}{2a} $ і вивести на екран.
Інакше вивести на екран «Коренів немає».&lt;/li&gt;
&lt;li&gt;Вийти з програми.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ця ж задача на мові програмування C# має вигляд (символьний запис):&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 2.1. Розв’язання квадратного рівняння.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;static void Main(string[] args)
{
    //Оголошуємо змінні
    double a, b, c, d, x1, x2;

    //Вводимо значення змінних з клавіатури
    Console.WriteLine(&amp;quot;Введіть a:&amp;quot;);
    a = Convert.ToDouble(Console.ReadLine());
    Console.WriteLine(&amp;quot;Введіть b:&amp;quot;);
    b = Convert.ToDouble(Console.ReadLine());
    Console.WriteLine(&amp;quot;Введіть c:&amp;quot;);
    c = Convert.ToDouble(Console.ReadLine());

    //Знаходимо дискримінант
    d = b * b - 4 * a * c;

    if (d &amp;gt; 0)
    {
        x1 = (-b + Math.Sqrt(d)) / (2 * a);
        x2 = (-b - Math.Sqrt(d)) / (2 * a);
        Console.WriteLine(&amp;quot;x1 = {0}, x2 = {1}&amp;quot;, x1, x2);
    }
    else if (d == 0)
    {
        x1 = -b / (2 * a);
        Console.WriteLine(&amp;quot;x = {0}&amp;quot;, x1);
    }
    else
        Console.WriteLine(&amp;quot;Коренів не існує.&amp;quot;);
    //Вихід з програми
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;22-побудова-алгоритмів-з-використанням-блок-схем&#34;&gt;2.2. Побудова алгоритмів з використанням блок-схем&lt;/h2&gt;
&lt;p&gt;Для зображення алгоритмів використовуватимемо блок-схеми, що формуються з типових блоків:&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-22-типові-блоки-для-формування-блок-схем-алгоритмів&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-algorithm-blocks-blocks.svg&#34; data-caption=&#34;Рис. 2.2. Типові блоки для формування блок-схем алгоритмів.&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-algorithm-blocks-blocks.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.2. Типові блоки для формування блок-схем алгоритмів.
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Усі блок-схеми створено у &lt;em&gt;draw.io&lt;/em&gt;.&lt;br&gt; Файли можна знайти &lt;a href=&#34;https://github.com/kleban/csharp-basics-public/blob/master/diagrams&#34;&gt;у github репозиторії курсу&lt;/a&gt;.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;У теорії алгоритмів доведено, що будь-який, скільки завгодно складний алгоритм може бути складений з трьох основних алгоритмічних структур: лінійної, розгалуження і циклу, показаних, відповідно на &lt;code&gt;рис. 2.3&lt;/code&gt;.&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-23-основні-алгоритмічні-структури&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-algorithm-blocks-structures.svg&#34; data-caption=&#34;Рис. 2.3. Основні алгоритмічні структури&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-algorithm-blocks-structures.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.3. Основні алгоритмічні структури
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;p&gt;Лінійна структура передбачає послідовне виконання дій, без їх повторення або пропуску деяких дій. Зазвичай програмісти прагнуть до того, аби алгоритм мав лінійну структуру.&lt;/p&gt;
&lt;p&gt;Структура &amp;ldquo;розгалуження&amp;rdquo; передбачає виконання однієї з двох груп дій залежно від виконання умови у блоці розгалуження. На рис. 3 знаком &amp;ldquo;+&amp;rdquo; показано виконання умови, а знаком &amp;ldquo;-&amp;rdquo; - його невиконання. Часто використовується неповна команда розгалуження, коли один з блоків дії відсутній.&lt;/p&gt;
&lt;p&gt;Структура &amp;ldquo;цикл&amp;rdquo; має декілька різновидів. На рис. 3 показаний цикл типу &amp;ldquo;доки&amp;rdquo; (&lt;code&gt;while&lt;/code&gt;) з передумовою. Дії всередині цього циклу повторюються доки виконується умова у блоці розгалуження, причому спочатку перевіряється умова, а потім виконується дія. Досить часто використовуються інші типи циклу, показані на &lt;code&gt;рис. 2.4&lt;/code&gt;.&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-24-зображення-циклів-за-допомогою-блок-схем&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-algorithm-blocks-loops.svg&#34; data-caption=&#34;Рис. 2.4. Зображення циклів за допомогою блок-схем&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-algorithm-blocks-loops.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.4. Зображення циклів за допомогою блок-схем
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;p&gt;У циклі з після умовою перевірка умови виходу з циклу виконується після чергової дії. Цикл &amp;ldquo;для (&lt;code&gt;for&lt;/code&gt;)&amp;rdquo; є модифікацією циклу &amp;ldquo;доки (&lt;code&gt;while&lt;/code&gt;)&amp;rdquo; для ситуації, коли заздалегідь відома кількість повторень деяких дій. Запис у блоці заголовка циклу на рис.3 показує приклад опису заголовка циклу, в якому дії повторюються стільки раз, скільки цілих значень набуває параметра циклу i від свого початкового значення 1 до кінцевого N з кроком 1. Зазвичай крок не вказується, якщо він дорівнює 1.&lt;/p&gt;
&lt;p&gt;Тепер запишемо алгоритм розв’язання задачі 1 у графічному вигляді.&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-25-блок-схема-алгоритму-знаходження-коренів-квадратного-рівняння-до-задачі-1&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task1.svg&#34; data-caption=&#34;Рис. 2.5. Блок-схема алгоритму знаходження коренів квадратного рівняння до задачі №1&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task1.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.5. Блок-схема алгоритму знаходження коренів квадратного рівняння до задачі №1
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;p&gt;Для закріплення знань по лінійних структурах та розгалуженнях побудуємо графічне відображення алгоритмів для кількох задач.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-question-circle text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Задача 2.&lt;/strong&gt; Побудувати блок-схему алгоритму перевірки введеного числа на невід’ємність.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-check-circle text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Розвязання задачі графічним способом:&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-26-блок-схема-алгоритму-знаходження-коренів-квадратного-рівняння-до-задачі-2&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task2.svg&#34; data-caption=&#34;Рис. 2.6. Блок-схема алгоритму знаходження коренів квадратного рівняння до задачі №2&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task2.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.6. Блок-схема алгоритму знаходження коренів квадратного рівняння до задачі №2
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;hr&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-question-circle text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Задача 3.&lt;/strong&gt; Побудувати блок-схему алгоритму зходження периметра та площі трикутника за формулою Герона.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-check-circle text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Розвязання задачі графічним способом:&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-27-блок-схема-алгоритму-до-задачі-3&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task3.svg&#34; data-caption=&#34;Рис. 2.7. Блок-схема алгоритму до задачі №3&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task3.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.7. Блок-схема алгоритму до задачі №3
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;hr&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-question-circle text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Задача 4.&lt;/strong&gt; Побудувати блок-схему алгоритму порівняння двох чисел.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-check-circle text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Розвязання задачі графічним способом:&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-28-блок-схема-до-задачі-4&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task4.svg&#34; data-caption=&#34;Рис. 2.8. Блок-схема до задачі №4&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task4.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.8. Блок-схема до задачі №4
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;hr&gt;
&lt;p&gt;Для закріплення знань по циклічних структурах побудуємо графічне відображення алгоритмів для кількох задач.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-question-circle text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Задача 5.&lt;/strong&gt; Побудувати блок-схему алгоритму знаходження суми елементів у масиву.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-info-circle text-primary  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Введемо позначення: $ n $ – кількість елементів масиву, $ sum $ – змінна, що визначає суму, $ x_i $ – $ і $-й елемент масиву.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-check-circle text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Розвязання задачі графічним способом:&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-29-блок-схема-до-задачі-5&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task5.svg&#34; data-caption=&#34;Рис. 2.9. Блок-схема до задачі №5&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task5.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.9. Блок-схема до задачі №5
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
 &lt;/center&gt;
&lt;hr&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-question-circle text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Задача 6.&lt;/strong&gt; Побудувати блок-схему алгоритму знаходження середнього значення елементів масиву.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-info-circle text-primary  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Ця задача відрізнється від попередньої лише появою нової змінної $ avg $ – середнє значення.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-check-circle text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Розвязання задачі графічним способом:&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-210-блок-схема-до-задачі-6&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task6.svg&#34; data-caption=&#34;Рис. 2.10. Блок-схема до задачі №6&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task6.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.10. Блок-схема до задачі №6
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
 &lt;/center&gt;
&lt;hr&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-question-circle text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Задача 7.&lt;/strong&gt; Побудувати блок-схему алгоритму знаходження максимального елемента у масиві.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-info-circle text-primary  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Введемо позначення: $ max $ – максимальний елемент, $ n $ - кількість елементів у масиві, $ x_i $ – $ і $-й елемент масиву. Припускаємо що масив уже заповнений і наперед відомо кількість елементів у масиві.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;far fa-check-circle text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;strong&gt;Розвязання задачі графічним способом:&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-211-блок-схема-до-задачі-7&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task7.svg&#34; data-caption=&#34;Рис. 2.11. Блок-схема до задачі №7&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/svg/lecture-2-tasks-task7.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.11. Блок-схема до задачі №7
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
 &lt;/center&gt;
&lt;hr&gt;
&lt;h2 id=&#34;23ствоерення-блок-схем-з-використанням-diagramm-designer&#34;&gt;2.3.	Ствоерення блок-схем з використанням Diagramm Designer&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Diagramm Designer&lt;/strong&gt; - програмне забезпечення для побудови блок-схем, UML-діаграм, та інших зображень на основі векторної графіки. 
&lt;a href=&#34;https://logicnet.dk/DiagramDesigner/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;
  &lt;i class=&#34;fas fa-download  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити актуальну версію DiagramDesigner можна тут&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Перелік базових функцій Diagramm Designer:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Налаштовувана палітра шаблонів.&lt;/li&gt;
&lt;li&gt;Перевірка правопису.&lt;/li&gt;
&lt;li&gt;Імпорт / експорт зображень &lt;code&gt;WMF&lt;/code&gt;, &lt;code&gt;EMF&lt;/code&gt;, &lt;code&gt;BMP&lt;/code&gt;, &lt;code&gt;JPEG&lt;/code&gt;, &lt;code&gt;PNG&lt;/code&gt;, &lt;code&gt;MNG&lt;/code&gt;, &lt;code&gt;ICO&lt;/code&gt;, &lt;code&gt;GIF&lt;/code&gt; та &lt;code&gt;PCX&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Переглядач слайд-шоу.&lt;/li&gt;
&lt;li&gt;Зручний графічний редактор для відображення математичних виразів.&lt;/li&gt;
&lt;li&gt;Калькулятор для розв&amp;rsquo;язання рівнянь.&lt;/li&gt;
&lt;li&gt;Інтеграція з &lt;code&gt;MeeSoft Image Analyzer&lt;/code&gt; для редагування растрових зображень.&lt;/li&gt;
&lt;li&gt;Мінімізація розміру файлів.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Розглянемо графічний інтерфейс продукту:&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-212-головне-вікно-програми-diagramm-designer-123&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/lecture2/diagramm_designer_1.png&#34; data-caption=&#34;Рис. 2.12. Головне вікно програми Diagramm Designer 1.23&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/lecture2/diagramm_designer_1.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.12. Головне вікно програми Diagramm Designer 1.23
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;p&gt;Для створення діаграм використовуєть технологія &lt;code&gt;Drag&amp;amp;Drop&lt;/code&gt;, тобто елементи можна перетягувати на робочу область.
Приклад створення діаграми можна переглянути на відео (у онлайн версії лекції).&lt;/p&gt;
&lt;p&gt;Документ &lt;code&gt;DiagrammDesigner&lt;/code&gt; може мати кілька сторінок, переключення між сторінками за допомогою меню &lt;code&gt;Diagram&lt;/code&gt; - &lt;code&gt;Rearrange pages&lt;/code&gt; (рис. 2.13).&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-213-вибір-сторінки-у-програмі-diagramm-designer&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/lecture2/diagramm_designer_2.png&#34; data-caption=&#34;Рис. 2.13. Вибір сторінки у програмі Diagramm Designer&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/lecture2/diagramm_designer_2.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.13. Вибір сторінки у програмі Diagramm Designer
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;p&gt;Для форматування тексту у межах графічних блоків (фігур) використовують наступні теги:&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-214-редагування-тексту-у-блоці-diagramm-designer&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/lecture2/diagramm_designer_3.png&#34; data-caption=&#34;Рис. 2.14. Редагування тексту у блоці Diagramm Designer.&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/lecture2/diagramm_designer_3.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.14. Редагування тексту у блоці Diagramm Designer.
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;Таблиця 2.1. Теги для форматування тексту у графічних блоках DiagrammDesigner&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Код&lt;/th&gt;
&lt;th&gt;Стиль&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\B…\b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Напівжирний&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\U…\u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Підкреслений&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\I…\i&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Курсив&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\O…\o&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Закреслений&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\\&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\H…\h&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Припіднятий до верху&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\S…\s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Символьний шрифт&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\p&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Номер сторінки&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\L…\l&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Опущений до низу&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\C######&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Колір у HTML&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\P&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Загловок сторінки&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Кількість сторінок&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\_&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Горизонтальний розділювач&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Новий рядок&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Підказка&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;Таблиця 2.2. Приклади форматування тексту у графічних блоках DiagrammDesigner&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Код з тегами&lt;/th&gt;
&lt;th&gt;Текст&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\B\ID=b\H2\h-4ac&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$ D=b^2-4ac $&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Вводимо значення &lt;code&gt;\Ba, b, c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Вводимо значення $ a $, $ b $, $ c $&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\ID &amp;gt; 0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$	D &amp;gt; 0 $&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Вводимо &lt;code&gt;\B\Ix\Li\i&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Вводимо $ x_i $&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;З іншими можливостями програмного подукту Diagramm Designer можна ознайомитися використовуючи вбудовану довідку програми.&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    Підтримка даного розділу лекції у майбутньому не планується і його варто використовувати швидше для ознайомлення та розширення кругозору слухачів курсу. Рекомендую використовувати &lt;code&gt;draw.io&lt;/code&gt;.
  &lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;h2 id=&#34;24ствоерення-блок-схем-з-використанням-drawio&#34;&gt;2.4.	Ствоерення блок-схем з використанням draw.io&lt;/h2&gt;
&lt;p&gt;Варто звернути увагу, що усі діаграми для лекцій створені саме у &lt;code&gt;draw.io&lt;/code&gt; і можете завантажити їх у 
&lt;a href=&#34;https://github.com/kleban/csharp-basics-public/blob/master/diagrams/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;публічному репозиторії курсу на github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;На даний момент проект є безкоштовним і розміщується за адресою 
&lt;a href=&#34;http://diagrams.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://diagrams.net/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Досить зручною функцією є інтеграція сервісами для зберігання файлів діаграм:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
  &lt;i class=&#34;fab fa-google-drive  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Google Drive.&lt;/li&gt;
&lt;li&gt;
  &lt;i class=&#34;fas fa-cloud  pr-1 fa-fw&#34;&gt;&lt;/i&gt; OneDrive.&lt;/li&gt;
&lt;li&gt;
  &lt;i class=&#34;fab fa-dropbox  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Dropbox.&lt;/li&gt;
&lt;li&gt;
  &lt;i class=&#34;fab fa-github  pr-1 fa-fw&#34;&gt;&lt;/i&gt; GitHub.&lt;/li&gt;
&lt;li&gt;
  &lt;i class=&#34;fab fa-gitlab  pr-1 fa-fw&#34;&gt;&lt;/i&gt; GitLab.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-215-вибір-джерела-для-збереження-drawio&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/lecture2/draw_io_1.png&#34; data-caption=&#34;Рис. 2.15. Вибір джерела для збереження &amp;lt;code&amp;gt;draw.io&amp;lt;/code&amp;gt;&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/lecture2/draw_io_1.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.15. Вибір джерела для збереження &lt;code&gt;draw.io&lt;/code&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;p&gt;Графічний інтерфейс &lt;code&gt;draw.io&lt;/code&gt; є досить зручним у користуванні і дозволяє доповнити перелік доступних зображень, блоків, логотипів продуктів для створення схем будь-якого рівня складності.&lt;/p&gt;
&lt;center&gt;
















&lt;figure id=&#34;figure-рис-216-ui-головного-вікна-програми-drawio-для-windows&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://kleban.page/media/courses/csharp-basics/lecture2/draw_io_2.png&#34; data-caption=&#34;Рис. 2.16. UI головного вікна програми &amp;lt;code&amp;gt;draw.io&amp;lt;/code&amp;gt; для &amp;lt;code&amp;gt;Windows&amp;lt;/code&amp;gt;&#34;&gt;


  &lt;img src=&#34;https://kleban.page/media/courses/csharp-basics/lecture2/draw_io_2.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 2.16. UI головного вікна програми &lt;code&gt;draw.io&lt;/code&gt; для &lt;code&gt;Windows&lt;/code&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;p&gt;Досить зручною є функція збереження діаграм для публікації у веб або на паперових носіях формати файлів (png, jpeg, svg, pdf, html, xml), а також вбудовування їх у різні типи документів, що надають сервіси &lt;code&gt;Google&lt;/code&gt; та &lt;code&gt;Microsoft&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Для початку ознайомлення з сервісом &lt;code&gt;draw.io&lt;/code&gt; рекомендую переглянути коротке відео:&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/Z0D96ZikMkc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Джерело: 
&lt;a href=&#34;https://www.youtube.com/channel/UCiTtRN9b8P4CoSfpkfgEJHA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;youtube канал draw.io&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-question-circle fa-2x text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;контрольні-запитання&#34;&gt;Контрольні запитання&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Дати визначення поняття «алгоритм»?&lt;/li&gt;
&lt;li&gt;Перелічіть властивості алгоритмів.&lt;/li&gt;
&lt;li&gt;Якими способами можна представити алгоритм?&lt;/li&gt;
&lt;li&gt;Які типові блоки для формування блок-схем алгоритмів ви знаєте? Як вони зображуються графічно?&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-book fa-2x text-primary  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;список-використаних-джерел&#34;&gt;Список використаних джерел&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ada Lovelace on Wikipedia. Url: &lt;a href=&#34;https://en.wikipedia.org/wiki/Ada_Lovelace&#34;&gt;https://en.wikipedia.org/wiki/Ada_Lovelace&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DiagramDesigner. Url: &lt;a href=&#34;https://logicnet.dk/DiagramDesigner/&#34;&gt;https://logicnet.dk/DiagramDesigner/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Draw.IO. Url: &lt;a href=&#34;https://www.diagrams.net/&#34;&gt;https://www.diagrams.net/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Albahari, J., &amp;amp; Albahari, B. (2012). C# 5.0 in a Nutshell, Fifth Edition. 1005 Gravenstein Highway North, Sebastopol, USA: O’Reilly Media, Inc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cardelli, L., &amp;amp; Wegner, P. (December 1985 p.). On Understanding Types, Data Abstraction, and Polymorphism. ACM Computing 1. Surveys, 17(4), сс. 149-154. Отримано з &lt;a href=&#34;http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf&#34;&gt;http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kort, W. d. (2013). Exam Ref 70-483: Programming in C#. Sebastopol, California 95472: O’Reilly Media, Inc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MSDN. (без дати). Отримано з Microsoft Developer Network: &lt;a href=&#34;http://msdn.microsoft.com/&#34;&gt;http://msdn.microsoft.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Биллиг, А. (2005). Основы программирования на C#. Москва, Россия: НОУ ИНТУИТ.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Нейгел, К. И. (2011). С# 4.0 и платформа .NET 4 для профессионалов. Москва, Россия: ООО &amp;ldquo;И.Д. Вильямс&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Павловская, Т. (2009). С#. Программирование на языке высокого уровня. Учебник для вузов. СПб, Россия: Питер.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!--
---


  &lt;i class=&#34;fas fa-list-alt fa-2x text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
## Задачі
--&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-download fa-2x  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;додаткові-матеріали-для-завнатаження&#34;&gt;Додаткові матеріали для завнатаження&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;del&gt;Лекція у форматі DOCX 
&lt;a href=&#34;&#34;&gt;
  &lt;i class=&#34;fas fa-file-word  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити&lt;/a&gt;&lt;/del&gt; (у розробці)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Лекція у форматі PDF 
&lt;a href=&#34;&#34;&gt;
  &lt;i class=&#34;fas fa-file-pdf  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити&lt;/a&gt;&lt;/del&gt; (у розробці)&lt;/li&gt;
&lt;li&gt;Діаграми до лекції у форматі &lt;code&gt;
  &lt;i class=&#34;fas fa-project-diagram  pr-1 fa-fw&#34;&gt;&lt;/i&gt;draw.io&lt;/code&gt; на &lt;code&gt;
  &lt;i class=&#34;fab fa-github  pr-1 fa-fw&#34;&gt;&lt;/i&gt;github&lt;/code&gt; 
&lt;a href=&#34;https://github.com/kleban/csharp-basics-public/tree/master/diagrams&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Перейти&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Дорогі друзі, якщо Ви помітили, що для написання матеріалів використані джерела, які я не вказав - прошу надіслати мені інформацію на пошту.
Дякую.
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
